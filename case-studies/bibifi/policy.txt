# Notes:
# * Yesod supports uniqueness constraints on any type, which we don't.
# * It also supports default values for fields in the model file,
# while we only support them during migrations.
# * It also supports custom enumeration types. Where used, these are noted in comments.

@static-principle
Admin

@principle
User {
    create: public,
    delete: public,

    ident: String { # Unique
        read: public,
        write: public,
    },
    password: String {
        read: public,
        write: public,
    },
    salt: String {
        read: public,
        write: public,
    },
    email: String { # Unique
        read: public,
        write: public,
    },
    created: DateTime { # default: now()
        read: public,
        write: public,
    },
    admin: Bool { # default: false
        read: public,
        write: public,
    },
    consentForm: Option(Id(StoredFile)) { # default: None
        read: public,
        write: public,
    },
    resume: Option(Id(StoredFile)) { # default: None
        read: public,
        write: public,
    },
}

CourseraUser {
    create: public,
    delete: public,

    courseraId: String { # Unique
        read: public,
        write: public,
    },
    user: Id(User) { # Unique
        read: public,
        write: public,
    },
    token: String {
        read: public,
        write: public,
    },
}

# Skipping UserInformation, does not appear to be policy-relevant

UserConfirmation {
    create: public,
    delete: public,

    user: Id(User) {
        read: public,
        write: public,
    },
    confirmation: String { # Unique
        read: public,
        write: public,
    },
}

Contest {
    create: public,
    delete: public,

    url: String { # Unique
        read: public,
        write: public,
    },
    title: String {
        read: public,
        write: public,
    },
    buildStart: DateTime {
        read: public,
        write: public,
    },
    buildEnd: DateTime {
        read: public,
        write: public,
    },
    breakFixStart: DateTime {
        read: public,
        write: public,
    }
    breakEnd: DateTime {
        read: public,
        write: public,
    }
    fixEnd: DateTime {
        read: public,
        write: public,
    }
    dependencies: Set(Id(Post)) { # Inlined from PostDependency
        read: public,
        write: public,
    }
}

CourseraContest {
    create: public,
    delete: public,

    contest: Id(Contest) { # Unique
        read: public,
        write: public,
    },
    courseId: I64 {
        read: public,
        write: public,
    },
    sessionId: I64 {
        read: public,
        write: public,
    },
}

Post {
    create: u -> [Admin],
    delete: u -> [Admin],

    title: String {
         read: public,
         write: u -> [Admin],
    },
    contest: Id(Contest) {
        read: public,
        write: public,
    },
    timestamp: DateTime { # default: now()
        read: public,
        write: public,
    },
    draft: Bool {
        read: public,
        write: public,
    },
    content: String { # No "HTML" type available, using "String"
        read: public,
        write: u -> [Admin],
    },
    markdown: String {
        read: public,
        write: u -> [Admin],
    },
}

Judge {
    create: public,
    delete: public,

    judge: Id(User) { # Unique
        read: public,
        write: public,
    },
    contest: Id(Contest) { # Unique
        read: public,
        write: public,
    },
    assignedCount: I64 { # default: 0
        read: public,
        write: public,
    },
    conflicts: Set(Id(TeamContest)) { # Inlined from JudgeConflict
        read: public,
        write: public,
    },
}

BuildJudgement {
    create: bj -> [Admin],
    delete: bj -> [bj.judge, Admin],

    judge: Id(Judge) {
        read: public,
        write: public,
    },
    submission: Id(BuildSubmission) { # Unique
        read: public,
        write: public,
    },
    ruling: Option(Bool) {
        read: public,
        write: bj -> [bj.judge, Admin],
    },
    comments: Option(String) {
        read: public,
        write: bj -> [bj.judge, Admin],
    },
}

BreakJudgement {
    create: bj -> [Admin],
    delete: bj -> [bj.judge, Admin],

    judge: Id(Judge) {
        read: public,
        write: public,
    },
    submission: Id(BreakSubmission) { # Unique
        read: public,
        write: public,
    },
    ruling: Option(Bool) {
        read: public,
        write: bj -> [bj.judge, Admin],
    },
    comments: Option(String) {
        read: public,
        write: bj -> [bj.judge, Admin],
    },
}

FixJudgement {
    create: bj -> [Admin],
    delete: bj -> [bj.judge, Admin],

    judge: Id(Judge) {
        read: public,
        write: public,
    },
    submission: Id(BreakSubmission) { # Unique
        read: public,
        write: public,
    },
    ruling: Option(Bool) {
        read: public,
        write: bj -> [bj.judge, Admin],
    },
    comments: Option(String) {
        read: public,
        write: bj -> [bj.judge, Admin],
    },
}

BreakDispute {
    create: public,
    delete: public,

    break: Id(BreakSubmission) { # Unique
        read: public,
        write: public,
    },
    justification: String {
        read: public,
        write: public,
    },
}

Team {
    create: public,
    delete: public,

    name: String { # Unique
        read: public,
        write: public,
    }
    leader: Id(User) {
        read: public,
        write: public,
    }
    members: Set(Id(User)) { # Inlined from TeamMember
        read: public,
        write: public,
    }
}

TeamContest {
    create: public,
    delete: public,

    team: Id(Team) { # Unique
        read: public,
        write: public,
    },
    contest: Id(Contest) { # Unique
        read: public,
        write: public,
    },
    gitUrl: String { # defualt=''
        read: public,
        write: public,
    },
    languages: String { # default=''
        read: public,
        write: public,
    },
    professional: Bool { # default=false
        read: public,
        write: public,
    },
    gitHookNonce: String {
        read: public,
        write: public,
    },
    gitRepositoryIdentifier: Option(String) {# external type: RepositoryIdentifier
        read: public,
        write: public,
    },
}

TeamInvite {
    create: public,
    delete: public,

    invite: String { # Unique
        read: public,
        write: public,
    },
    team: Id(Team) {
        read: public,
        write: public,
    },
    email: String {
        read: public,
        write: public,
    },
}

PasswordResetInvite {
    create: u -> [Admin],
    delete: u -> [Admin],

    account: Id(User) {
        read: public,
        write: public,
    },
    invite: String { # Unique
        read: public,
        write: u -> [Admin],
    },
    expiration: DateTime {
        read: public,
        write: public,
    },
}

ContestCoreTest {
    create: public,
    delete: public,

    contest: Id(Contest) {
        read: public,
        write: public,
    },
    name: String {
        read: public,
        write: public,
    },
    inputFile: String {
        read: public,
        write: public,
    },
    outputFile: String {
        read: public,
        write: public,
    },
    testScript: String {
        read: public,
        write: public,
    }
}

ContestPerformanceTest {
    create: public,
    delete: public,

    contest: Id(Contest) {
        read: public,
        write: public,
    },
    name: String {
        read: public,
        write: public,
    },
    inputFile: String {
        read: public,
        write: public,
    },
    outputFile: String {
        read: public,
        write: public,
    },
    testScript: String {
        read: public,
        write: public,
    },
    optional: Bool { # default=false
        read: public,
        write: public,
    },
}

ContestOptionalTest {
    create: public,
    delete: public,

    contest: Id(Contest) {
        read: public,
        write: public,
    },
    name: String {
        read: public,
        write: public,
    },
    inputFile: String {
        read: public,
        write: public,
    },
    outputFile: String {
        read: public,
        write: public,
    },
    testScript: String {
        read: public,
        write: public,
    }
}

TeamBreakScore {
    create: public,
    delete: public,

    team: Id(TeamContest) {
        read: public,
        write: public,
    },
    buildScore: Option(F64) { # default=Some(0.0)
        read: public,
        write: public,
    },
    breakScore: Option(F64) {
        read: public,
        write: public,
    },
    fixScore: Option(F64) {
        read: public,
        write: public,
    },
    timestamp: DateTime {
        read: public,
        write: public,
    },
}

TeamBuildScore {
    create: public,
    delete: public,

    team: Id(TeamContest) {
        read: public,
        write: public,
    },
    buildScore: Option(F64) {
        read: public,
        write: public,
    },
    breakScore: Option(F64) {
        read: public,
        write: public,
    },
    fixScore: Option(F64) {
        read: public,
        write: public,
    },
    timestamp: DateTime {
        read: public,
        write: public,
    },
}

OracleSubmission {
    create: public,
    delete: public,

    team: Id(TeamContest) {
        read: public,
        write: public,
    },
    timestamp: DateTime {
        read: public,
        write: public,
    },
    name: String {
        read: public,
        write: public,
    },
    input: String {
        read: public,
        write: public,
    },
    output: Option(String) {
        read: public,
        write: public,
    },
    status: String { # External type: OracleSubmissionStatus
        read: public,
        write: public,
    },
}
BuildSubmission {
    create: public,
    delete: public,

    team: Id(TeamContest) {
        read: public,
        write: public,
    },
    timestamp: DateTime {
        read: public,
        write: public,
    },
    commitHash: String {
        read: public,
        write: public,
    },
    status: String { # External type: BuildSubmissionStatus
        read: public,
        write: public,
    },
    stdout: Option(String) { # Textarea type? default=None
        read: public,
        write: public,
    },
    stderr: Option(String) { # Textarea type? default=None
        read: public,
        write: public,
    },
    file: Option(String) { # Inlined from BuildSubmissionFile
        read: public,
        write: public,
    },
}

BreakOracleSubmission {
    create: u -> [Admin],
    delete: u -> [Admin],
    team: Id(TeamContest) {
        read: public,
        write: u -> [Admin],
    },
    timestamp: DateTime {
        read: public,
        write: u -> [Admin],
    },
    description: String {
        read: public,
        write: u -> [Admin],
    },
    valid: Bool {
        read: public,
        write: u -> [Admin],
    }
}

BreakSubmission {
    create: public,
    delete: public,

    team: Id(TeamContest) {
        read: public,
        write: public,
    },
    targetTeam: Option(Id(TeamContest)) {
        read: public,
        write: public,
    },
    timestamp: DateTime {
        read: public,
        write: public,
    },
    commitHash: String {
        read: public,
        write: public,
    },
    name: String { # default=''
        read: public,
        write: public,
    },
    status: String { # External type: BreakSubmissionStatus
        read: public,
        write: public,
    },
    breakType: Option(String) { # External type: BreakType
        read: public,
        write: public,
    },
    message: Option(String) {
        read: public,
        write: public,
    },
    json: Option(String) {
        read: public,
        write: public,
    },
    stdout: Option(String) { # Textarea type? default=Some('')
        read: public,
        write: public,
    },
    stderr: Option(String) { # Textarea type? default=Some('')
        read: public,
        write: public,
    },
    valid: Option(Bool) {
        read: public,
        write: public,
    },
    file: Option(String) { # Inlined from BreakSubmissionFile
        read: public,
        write: public,
    },
}

BreakFixSubmission {
    create: public,
    delete: public,

    break: Id(BreakSubmission) {
        read: public,
        write: public,
    },
    fix: Option(Id(FixSubmission)) {
        read: public,
        write: public,
    },
    result: String { # External type: BreakSubmissionResult
        read: public,
        write: public,
    },
}

FixSubmission {
    create: public,
    delete: public,

    team: Id(TeamContest) {
        read: public,
        write: public,
    },
    timestamp: DateTime {
        read: public,
        write: public,
    },
    commitHash: String {
        read: public,
        write: public,
    },
    status: String { # External type: FixSubmissionStatus
        read: public,
        write: public,
    },
    result: Option(String) { # External type: FixSubmissionResult
        read: public,
        write: public,
    },
    message: Option(String) {
        read: public,
        write: public,
    },
    stdout: Option(String) { # Textarea type? default=Some('')
        read: public,
        write: public,
    },
    stderr: Option(String) { # Textarea type? default=Some('')
        read: public,
        write: public,
    },
    file: Option(String) { # inlined from FixSubmissionFile
        read: public,
        write: public,
    },
}

BuildCoreResult {
    create: public,
    delete: public,

    submission: Id(BuildSubmission) { # Unique
        read: public,
        write: public,
    },
    test: Id(ContestCoreTest) { # Unique
        read: public,
        write: public,
    },
    pass: Bool {
        read: public,
        write: public,
    },
    message: Option(String) {
        read: public,
        write: public,
    },
}

BuildPerformanceResult {
    create: public,
    delete: public,

    submission: Id(BuildSubmission) { # Unique
        read: public,
        write: public,
    },
    test: Id(ContestPerformanceTest) { # Unique
        read: public,
        write: public,
    },
    time: Option(F64) {
        read: public,
        write: public,
    },
    message: Option(String) {
        read: public,
        write: public,
    },
}

BuildOptionalResult {
    create: public,
    delete: public,

    submission: Id(BuildSubmission) { # Unique
        read: public,
        write: public,
    },
    test: Id(ContestOptionalTest) { # Unique
        read: public,
        write: public,
    },
    pass: Bool {
        read: public,
        write: public,
    },
    message: Option(String) {
        read: public,
        write: public,
    },
}

FixCoreResult {
    create: public,
    delete: public,

    submission: Id(FixSubmission) { # Unique
        read: public,
        write: public,
    },
    test: Id(ContestCoreTest) { # Unique
        read: public,
        write: public,
    },
    pass: Bool {
        read: public,
        write: public,
    },
    message: Option(String) {
        read: public,
        write: public,
    },
}

FixPerformanceResult {
    create: public,
    delete: public,

    submission: Id(FixSubmission) { # Unique
        read: public,
        write: public,
    },
    test: Id(ContestPerformanceTest) { # Unique
        read: public,
        write: public,
    },
    time: Option(F64) {
        read: public,
        write: public,
    },
    message: Option(String) {
        read: public,
        write: public,
    },
}

FixOptionalResult {
    create: public,
    delete: public,

    submission: Id(FixSubmission) { # Unique
        read: public,
        write: public,
    },
    test: Id(ContestOptionalTest) { # Unique
        read: public,
        write: public,
    },
    pass: Bool {
        read: public,
        write: public,
    },
    message: Option(String) {
        read: public,
        write: public,
    },
}

Configuration {
    create: u -> [Admin],
    delete: u -> [Admin],

    key: String { # Unique
        read: public,
        write: u -> [Admin],
    }
    value: String {
        read: public,
        write: u -> [Admin],
    }
}

CacheExpiration {
    create: public,
    delete: public,

    key: String { # Unique
        read: public,
        write: public,
    },
    expiration: DateTime { # default=now()
        read: public,
        write: public,
    },
}

CacheBuildersCode {
    create: public,
    delete: public,

    team: String {
        read: public,
        write: public,
    },
    teamId: Id(TeamContest) { # Unique
        read: public,
        write: public,
    },
    languages: String { # default=''
        read: public,
        write: public,
    },
    contestId: Id(Contest) {
        read: public,
        write: public,
    },
    builderScore: F64 {
        read: public,
        write: public,
    },
    bugsFound: I64 {
        read: public,
        write: public,
    },
    vulnerabilitiesFound: I64 {
        read: public,
        write: public,
    },
}

StoredFile {
    create: public,
    delete: public,

    owner: Option(Id(User)) {
        read: public,
        write: public,
    },
    name: String {
        read: public,
        write: public,
    },
    contentType: String {
        read: public,
        write: public,
    },
    content: String {
        read: public,
        write: public,
    },
}

Error {
    create: public,
    delete: public,

    handlerName: String {
        read: public,
        write: public,
    },
    errorText: String {
        read: public,
        write: public,
    },
    time: DateTime { # default=now()
        read: public,
        write: public,
    },
}

RateLimiting {
    create: public,
    delete: public,

    action: I64 {
        read: public,
        write: public,
    },
    limiter: I64 {
        read: public,
        write: public,
    },
    time: DateTime { # default=now()
        read: public,
        write: public,
    },
}

ScorePending {
    create: public,
    delete: public,

    contest: Id(Contest) { # Unique
        read: public,
        write: public,
    },
    round: String { # Unique, External type: ContestRound
        read: public,
        write: public,
    },
}
