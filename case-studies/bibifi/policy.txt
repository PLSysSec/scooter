# Notes:
# * Yesod supports uniqueness constraints on any type, which we don't.
# * It also supports default values for fields in the model file,
# while we only support them during migrations.
# * It also supports custom enumeration types. Where used, these are noted in comments.

@static-principal
Admin

@principal
User {
    create: public,
    delete: public,

    # Unique
    ident: String {
        read: public,
        write: public,
    },
    password: String {
        read: public,
        write: public,
    },
    salt: String {
        read: public,
        write: public,
    },
    # Unique
    email: String {
        read: public,
        write: public,
    },
    # default: now()
    created: DateTime {
        read: public,
        write: public,
    },
    # default: false
    admin: Bool {
        read: public,
        write: public,
    },
    # default: None
    consentForm: Option(Id(StoredFile)) {
        read: public,
        write: public,
    },
    # default: None
    resume: Option(Id(StoredFile)) {
        read: public,
        write: public,
    },
}

CourseraUser {
    create: public,
    delete: public,

    # Unique
    courseraId: String {
        read: public,
        write: public,
    },
    # Unique
    user: Id(User) {
        read: public,
        write: public,
    },
    token: String {
        read: public,
        write: public,
    },
}

# Skipping UserInformation, does not appear to be policy-relevant

UserConfirmation {
    create: public,
    delete: public,

    user: Id(User) {
        read: public,
        write: public,
    },
    # Unique
    confirmation: String {
        read: public,
        write: public,
    },
}

Contest {
    create: public,
    delete: public,

    # Unique
    url: String {
        read: public,
        write: public,
    },
    title: String {
        read: public,
        write: public,
    },
    buildStart: DateTime {
        read: public,
        write: public,
    },
    buildEnd: DateTime {
        read: public,
        write: public,
    },
    breakFixStart: DateTime {
        read: public,
        write: public,
    },
    breakEnd: DateTime {
        read: public,
        write: public,
    },
    fixEnd: DateTime {
        read: public,
        write: public,
    },
    # Inlined from PostDependency
    dependencies: Set(Id(Post)) {
        read: public,
        write: public,
    },
}

CourseraContest {
    create: public,
    delete: public,

    # Unique
    contest: Id(Contest) {
        read: public,
        write: public,
    },
    courseId: I64 {
        read: public,
        write: public,
    },
    sessionId: I64 {
        read: public,
        write: public,
    },
}

Post {
    create: u -> [Admin],
    delete: u -> [Admin],

    title: String {
         read: public,
         write: u -> [Admin],
    },
    contest: Id(Contest) {
        read: public,
        write: public,
    },
    # default: now()
    timestamp: DateTime {
        read: public,
        write: public,
    },
    draft: Bool {
        read: public,
        write: public,
    },
    # No "HTML" type available, using "String"
    content: String {
        read: public,
        write: u -> [Admin],
    },
    markdown: String {
        read: public,
        write: u -> [Admin],
    },
}

@principal
Judge {
    create: public,
    delete: public,

    # Unique
    judge: Id(User) {
        read: public,
        write: public,
    },
    # Unique
    contest: Id(Contest) {
        read: public,
        write: public,
    },
    # default: 0
    assignedCount: I64 {
        read: public,
        write: public,
    },
    # Inlined from JudgeConflict
    conflicts: Set(Id(TeamContest)) {
        read: public,
        write: public,
    },
}

BuildJudgement {
    create: bj -> [Admin],
    delete: bj -> [bj.judge, Admin],

    judge: Id(Judge) {
        read: public,
        write: public,
    },
    # Unique
    submission: Id(BuildSubmission) {
        read: public,
        write: public,
    },
    ruling: Option(Bool) {
        read: public,
        write: bj -> [bj.judge, Admin],
    },
    comments: Option(String) {
        read: public,
        write: bj -> [bj.judge, Admin],
    },
}

BreakJudgement {
    create: bj -> [Admin],
    delete: bj -> [bj.judge, Admin],

    judge: Id(Judge) {
        read: public,
        write: public,
    },
    # Unique
    submission: Id(BreakSubmission) {
        read: public,
        write: public,
    },
    ruling: Option(Bool) {
        read: public,
        write: bj -> [bj.judge, Admin],
    },
    comments: Option(String) {
        read: public,
        write: bj -> [bj.judge, Admin],
    },
}

FixJudgement {
    create: bj -> [Admin],
    delete: bj -> [bj.judge, Admin],

    judge: Id(Judge) {
        read: public,
        write: public,
    },
    # Unique
    submission: Id(BreakSubmission) {
        read: public,
        write: public,
    },
    ruling: Option(Bool) {
        read: public,
        write: bj -> [bj.judge, Admin],
    },
    comments: Option(String) {
        read: public,
        write: bj -> [bj.judge, Admin],
    },
}

BreakDispute {
    create: public,
    delete: public,

    # Unique
    breakSub: Id(BreakSubmission) {
        read: public,
        write: public,
    },
    justification: String {
        read: public,
        write: public,
    },
}

Team {
    create: public,
    delete: public,

    # Unique
    name: String {
        read: public,
        write: public,
    },
    leader: Id(User) {
        read: public,
        write: public,
    },
    # Inlined from TeamMember
    members: Set(Id(User)) {
        read: public,
        write: public,
    },
}

TeamContest {
    create: public,
    delete: public,

    # Unique
    team: Id(Team) {
        read: public,
        write: public,
    },
    # Unique
    contest: Id(Contest) {
        read: public,
        write: public,
    },
    # default=''
    gitUrl: String {
        read: public,
        write: public,
    },
    # default=''
    languages: String {
        read: public,
        write: public,
    },
    # default=false
    professional: Bool {
        read: public,
        write: public,
    },
    gitHookNonce: String {
        read: public,
        write: public,
    },
    # external type: RepositoryIdentifier
    gitRepositoryIdentifier: Option(String) {
        read: public,
        write: public,
    },
}

TeamInvite {
    create: public,
    delete: public,

    # Unique
    invite: String {
        read: public,
        write: public,
    },
    team: Id(Team) {
        read: public,
        write: public,
    },
    email: String {
        read: public,
        write: public,
    },
}

PasswordResetInvite {
    create: u -> [Admin],
    delete: u -> [Admin],

    account: Id(User) {
        read: public,
        write: public,
    },
    # Unique
    invite: String {
        read: public,
        write: u -> [Admin],
    },
    expiration: DateTime {
        read: public,
        write: public,
    },
}

ContestCoreTest {
    create: public,
    delete: public,

    contest: Id(Contest) {
        read: public,
        write: public,
    },
    name: String {
        read: public,
        write: public,
    },
    inputFile: String {
        read: public,
        write: public,
    },
    outputFile: String {
        read: public,
        write: public,
    },
    testScript: String {
        read: public,
        write: public,
    },
}

ContestPerformanceTest {
    create: public,
    delete: public,

    contest: Id(Contest) {
        read: public,
        write: public,
    },
    name: String {
        read: public,
        write: public,
    },
    inputFile: String {
        read: public,
        write: public,
    },
    outputFile: String {
        read: public,
        write: public,
    },
    testScript: String {
        read: public,
        write: public,
    },
    # default=false
    optional: Bool {
        read: public,
        write: public,
    },
}

ContestOptionalTest {
    create: public,
    delete: public,

    contest: Id(Contest) {
        read: public,
        write: public,
    },
    name: String {
        read: public,
        write: public,
    },
    inputFile: String {
        read: public,
        write: public,
    },
    outputFile: String {
        read: public,
        write: public,
    },
    testScript: String {
        read: public,
        write: public,
    },
}

TeamBreakScore {
    create: public,
    delete: public,

    team: Id(TeamContest) {
        read: public,
        write: public,
    },
    # default=Some(0.0)
    buildScore: Option(F64) {
        read: public,
        write: public,
    },
    breakScore: Option(F64) {
        read: public,
        write: public,
    },
    fixScore: Option(F64) {
        read: public,
        write: public,
    },
    timestamp: DateTime {
        read: public,
        write: public,
    },
}

TeamBuildScore {
    create: public,
    delete: public,

    team: Id(TeamContest) {
        read: public,
        write: public,
    },
    buildScore: Option(F64) {
        read: public,
        write: public,
    },
    breakScore: Option(F64) {
        read: public,
        write: public,
    },
    fixScore: Option(F64) {
        read: public,
        write: public,
    },
    timestamp: DateTime {
        read: public,
        write: public,
    },
}

OracleSubmission {
    create: public,
    delete: public,

    team: Id(TeamContest) {
        read: public,
        write: public,
    },
    timestamp: DateTime {
        read: public,
        write: public,
    },
    name: String {
        read: public,
        write: public,
    },
    input: String {
        read: public,
        write: public,
    },
    output: Option(String) {
        read: public,
        write: public,
    },
    # External type: OracleSubmissionStatus
    status: String {
        read: public,
        write: public,
    },
}
BuildSubmission {
    create: public,
    delete: public,

    team: Id(TeamContest) {
        read: public,
        write: public,
    },
    timestamp: DateTime {
        read: public,
        write: public,
    },
    commitHash: String {
        read: public,
        write: public,
    },
    # External type: BuildSubmissionStatus
    status: String {
        read: public,
        write: public,
    },
    # Textarea type? default=None
    stdout: Option(String) {
        read: public,
        write: public,
    },
    # Textarea type? default=None
    stderr: Option(String) {
        read: public,
        write: public,
    },
    # Inlined from BuildSubmissionFile
    file: Option(String) {
        read: public,
        write: public,
    },
}

BreakOracleSubmission {
    create: u -> [Admin],
    delete: u -> [Admin],
    team: Id(TeamContest) {
        read: public,
        write: u -> [Admin],
    },
    timestamp: DateTime {
        read: public,
        write: u -> [Admin],
    },
    description: String {
        read: public,
        write: u -> [Admin],
    },
    valid: Bool {
        read: public,
        write: u -> [Admin],
    },
}

BreakSubmission {
    create: public,
    delete: public,

    team: Id(TeamContest) {
        read: public,
        write: public,
    },
    targetTeam: Option(Id(TeamContest)) {
        read: public,
        write: public,
    },
    timestamp: DateTime {
        read: public,
        write: public,
    },
    commitHash: String {
        read: public,
        write: public,
    },
    # default=''
    name: String {
        read: public,
        write: public,
    },
    # External type: BreakSubmissionStatus
    status: String {
        read: public,
        write: public,
    },
    # External type: BreakType
    breakType: Option(String) {
        read: public,
        write: public,
    },
    message: Option(String) {
        read: public,
        write: public,
    },
    json: Option(String) {
        read: public,
        write: public,
    },
    # Textarea type? default=Some('')
    stdout: Option(String) {
        read: public,
        write: public,
    },
    # Textarea type? default=Some('')
    stderr: Option(String) {
        read: public,
        write: public,
    },
    valid: Option(Bool) {
        read: public,
        write: public,
    },
    # Inlined from BreakSubmissionFile
    file: Option(String) {
        read: public,
        write: public,
    },
}

BreakFixSubmission {
    create: public,
    delete: public,

    breakSub: Id(BreakSubmission) {
        read: public,
        write: public,
    },
    fix: Option(Id(FixSubmission)) {
        read: public,
        write: public,
    },
    # External type: BreakSubmissionResult
    result: String {
        read: public,
        write: public,
    },
}

FixSubmission {
    create: public,
    delete: public,

    team: Id(TeamContest) {
        read: public,
        write: public,
    },
    timestamp: DateTime {
        read: public,
        write: public,
    },
    commitHash: String {
        read: public,
        write: public,
    },
    # External type: FixSubmissionStatus
    status: String {
        read: public,
        write: public,
    },
    # External type: FixSubmissionResult
    result: Option(String) {
        read: public,
        write: public,
    },
    message: Option(String) {
        read: public,
        write: public,
    },
    # Textarea type? default=Some('')
    stdout: Option(String) {
        read: public,
        write: public,
    },
    # Textarea type? default=Some('')
    stderr: Option(String) {
        read: public,
        write: public,
    },
    # inlined from FixSubmissionFile
    file: Option(String) {
        read: public,
        write: public,
    },
}

BuildCoreResult {
    create: public,
    delete: public,

    # Unique
    submission: Id(BuildSubmission) {
        read: public,
        write: public,
    },
    # Unique
    test: Id(ContestCoreTest) {
        read: public,
        write: public,
    },
    pass: Bool {
        read: public,
        write: public,
    },
    message: Option(String) {
        read: public,
        write: public,
    },
}

BuildPerformanceResult {
    create: public,
    delete: public,

    # Unique
    submission: Id(BuildSubmission) {
        read: public,
        write: public,
    },
    # Unique
    test: Id(ContestPerformanceTest) {
        read: public,
        write: public,
    },
    time: Option(F64) {
        read: public,
        write: public,
    },
    message: Option(String) {
        read: public,
        write: public,
    },
}

BuildOptionalResult {
    create: public,
    delete: public,

    # Unique
    submission: Id(BuildSubmission) {
        read: public,
        write: public,
    },
    # Unique
    test: Id(ContestOptionalTest) {
        read: public,
        write: public,
    },
    pass: Bool {
        read: public,
        write: public,
    },
    message: Option(String) {
        read: public,
        write: public,
    },
}

FixCoreResult {
    create: public,
    delete: public,

    # Unique
    submission: Id(FixSubmission) {
        read: public,
        write: public,
    },
    # Unique
    test: Id(ContestCoreTest) {
        read: public,
        write: public,
    },
    pass: Bool {
        read: public,
        write: public,
    },
    message: Option(String) {
        read: public,
        write: public,
    },
}

FixPerformanceResult {
    create: public,
    delete: public,

    # Unique
    submission: Id(FixSubmission) {
        read: public,
        write: public,
    },
    # Unique
    test: Id(ContestPerformanceTest) {
        read: public,
        write: public,
    },
    time: Option(F64) {
        read: public,
        write: public,
    },
    message: Option(String) {
        read: public,
        write: public,
    },
}

FixOptionalResult {
    create: public,
    delete: public,

    # Unique
    submission: Id(FixSubmission) {
        read: public,
        write: public,
    },
    # Unique
    test: Id(ContestOptionalTest) {
        read: public,
        write: public,
    },
    pass: Bool {
        read: public,
        write: public,
    },
    message: Option(String) {
        read: public,
        write: public,
    },
}

Configuration {
    create: u -> [Admin],
    delete: u -> [Admin],

    # Unique
    key: String {
        read: public,
        write: u -> [Admin],
    },
    value: String {
        read: public,
        write: u -> [Admin],
    },
}

CacheExpiration {
    create: public,
    delete: public,

    # Unique
    key: String {
        read: public,
        write: public,
    },
    # default=now()
    expiration: DateTime {
        read: public,
        write: public,
    },
}

CacheBuildersCode {
    create: public,
    delete: public,

    team: String {
        read: public,
        write: public,
    },
    # Unique
    teamId: Id(TeamContest) {
        read: public,
        write: public,
    },
    # default=''
    languages: String {
        read: public,
        write: public,
    },
    contestId: Id(Contest) {
        read: public,
        write: public,
    },
    builderScore: F64 {
        read: public,
        write: public,
    },
    bugsFound: I64 {
        read: public,
        write: public,
    },
    vulnerabilitiesFound: I64 {
        read: public,
        write: public,
    },
}

StoredFile {
    create: public,
    delete: public,

    owner: Option(Id(User)) {
        read: public,
        write: public,
    },
    name: String {
        read: public,
        write: public,
    },
    contentType: String {
        read: public,
        write: public,
    },
    content: String {
        read: public,
        write: public,
    },
}

Error {
    create: public,
    delete: public,

    handlerName: String {
        read: public,
        write: public,
    },
    errorText: String {
        read: public,
        write: public,
    },
    # default=now()
    time: DateTime {
        read: public,
        write: public,
    },
}

RateLimiting {
    create: public,
    delete: public,

    action: I64 {
        read: public,
        write: public,
    },
    limiter: I64 {
        read: public,
        write: public,
    },
    # default=now()
    time: DateTime {
        read: public,
        write: public,
    },
}

ScorePending {
    create: public,
    delete: public,

    # Unique
    contest: Id(Contest) {
        read: public,
        write: public,
    },
    # Unique, External type: ContestRound
    round: String {
        read: public,
        write: public,
    },
}
