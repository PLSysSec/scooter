use crate::ast::*;
use std::str::FromStr;
grammar;

pub GlobalPolicy: GlobalPolicy = {
    <cp:CollectionPolicy*> => GlobalPolicy { collections: cp}
}

CollectionPolicy: CollectionPolicy = {
    <i:Ident> "{" "create" ":" <cp:Policy> "," "delete" ":" <dp:Policy> "," <fp:FieldPolicy*> "}"  => CollectionPolicy {
        name: i,
        create: cp,
        delete: dp,
        fields: fp.into_iter().collect()
    }
}

FieldPolicy: (String, FieldPolicy) = {
    <i:Ident> ":" <t: FieldType> "{" "read" ":" <r:Policy> "," "write" ":" <w:Policy> "," "}" "," =>
        (i.to_string(), FieldPolicy {
            ty: t,
            read: r,
            write: w
        })
}


FieldType: FieldType = {
    "String" => FieldType::String,
    "I64" => FieldType::I64,
    "F64" => FieldType::F64,
    "Id" "(" <coll:Ident> ")" => FieldType::Id(coll),
}

Policy: Policy = {
    "public" => Policy::Public,
    "none" => Policy::None,
    Func => Policy::Func(<>)
}

Func: Func = {
    <i:Ident> "->" <e:QueryExpr> => Func {
        param: i,
        expr: e
    }
}
FieldInitializer: (String, Box<QueryExpr>) = {
    <i:Ident> ":" <q:QueryExpr> => (i, q)
}
Object: ObjectLiteral = {
    <i:Ident> "{" <fs:Comma<FieldInitializer>> "}" => ObjectLiteral{ coll: i, fields: fs, template_obj: None},
    <i:Ident> "{" <fs:Comma<FieldInitializer>> "..." <e:QueryExpr> "}" => ObjectLiteral {coll: i, fields: fs, template_obj: Some(e)}
}
FieldTypeDeclaration: (String, FieldType) = {
    <i:Ident> ":" <t:FieldType> => (i, t)
}
ObjectType: Vec<(String, FieldType)> = {
    "{" <fs:Comma<FieldTypeDeclaration>> "}" => fs
}
Comma<T>: Vec<T> = { // (1)
    <v:(<T> ",")*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

QueryExpr: Box<QueryExpr> = {
    <l: QueryExpr> "+" <r: QueryExpr2> => Box::new(QueryExpr::Plus(l, r)),
    QueryExpr2
}

QueryExpr2: Box<QueryExpr> = {
    Path => Box::new(QueryExpr::Path(<>)),
    <s:r#""(.*)""#> => Box::new(QueryExpr::StringConst(
        s.get(1..s.len()-1).unwrap().to_string())),
    <i:r"[0-9]+"> => Box::new(QueryExpr::IntConst(i64::from_str(i).unwrap())),
    <f:r"[0-9]+\.[0-9]+"> => Box::new(QueryExpr::FloatConst(f64::from_str(f).unwrap())),
    Object => Box::new(QueryExpr::Object(<>)),
}

Ident: String = {
    <s:r"[a-zA-Z)]\w*"> => s.to_string()
}

Path: Vec<String> = {
    <v:(<Ident> ".")*> <i:Ident?> => match i {
        None => v,
        Some(i) => {
            let mut v = v;
            v.push(i);
            v
        }
    }
}

// Migration Lang stuff

pub Migration: Migration = {
    <cp:MigrationCommand*> => Migration(cp)
}

MigrationAction: MigrationAction = {
    "RemoveField" "(" <c:Ident> ")" =>
        MigrationAction::RemoveField{field:c},
    "AddField" "(" <c:Ident> "," <ty:FieldType> "," <vf:Func> ")" =>
        MigrationAction::AddField{field:c, ty:ty, init:vf},
    "ChangeField" "(" <c:Ident> "," <ty:FieldType> "," <vf:Func> ")" =>
        MigrationAction::ChangeField{field:c, new_ty:ty, new_init:vf},
    "RenameField" "(" <f_old:Ident> "," <f_new:Ident> ")" =>
        MigrationAction::RenameField{old_field:f_old, new_field: f_new},
    "ForEach" "(" <p:Ident> "->" <c:ObjectCommand> ")" =>
        MigrationAction::ForEach{param:p, body:c},
}

MigrationCommand: MigrationCommand = {
    <t:Ident> "::" <m:MigrationAction> =>
        MigrationCommand::CollAction{table: t, action: m},
    "CreateCollection" "(" <i:Ident> "," <t:ObjectType> ")" =>
        MigrationCommand::Create{table_name: i, layout: t},
    "DeleteCollection" "(" <i:Ident> ")" =>
        MigrationCommand::Delete{table_name: i},
}

ObjectCommand: ObjectCommand = {
    <t:Ident> "::" "Create" "(" <e:QueryExpr> ")" =>
        ObjectCommand::CreateObject{collection:t, value:e},
    <t:Ident> "::" "Delete" "(" <e:QueryExpr> ")" =>
        ObjectCommand::DeleteObject{collection:t, id_expr:e},
}
